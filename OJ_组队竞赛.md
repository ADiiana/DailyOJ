# OJ_组队竞赛

牛客网上的链接：[组队竞赛](https://www.nowcoder.com/questionTerminal/6736cc3ffd1444a4a0057dee89be789b?orderByHotValue=1&page=1&onlyReference=false)

题目描述：

> 来源：牛客网
>
> 牛牛举办了一次编程比赛,参加比赛的有3*n个选手,每个选手都有一个水平值a_i.现在要将这些选手进行组队,一共组成n个队伍,即每个队伍3人.牛牛发现队伍的水平值等于该队伍队员中第二高水平值。
>
>    例如:
>
>    一个队伍三个队员的水平值分别是3,3,3.那么队伍的水平值是3
>
>    一个队伍三个队员的水平值分别是3,2,3.那么队伍的水平值是3
>
>    一个队伍三个队员的水平值分别是1,5,2.那么队伍的水平值是2
>
>    为了让比赛更有看点,牛牛想安排队伍使所有队伍的水平值总和最大。
>
>    如样例所示:
>
>    如果牛牛把6个队员划分到两个队伍
>
>    如果方案为:
>
>    team1:{1,2,5}, team2:{5,5,8}, 这时候水平值总和为7.
>
>    而如果方案为:
>
>    team1:{2,5,8}, team2:{1,5,5}, 这时候水平值总和为10.
>
>    没有比总和为10更大的方案,所以输出10.
>
> ##### **输入描述:**
>
> ```
> 输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)
> 
> 第二行包括3*n个整数a_i(1 ≤ a_i ≤ 10^9),表示每个参赛选手的水平值.
> ```
>
> ##### **输出描述:**
>
> ```
> 输出一个整数表示所有队伍的水平值总和最大值.
> ```
>
>  示例1 
>
> ## 输入
>
> ```
> 2
> 5 2 8 5 1 5
> ```
>
> ## 输出
>
> ```
> 10
> ```

**题目总结：**即给定一个n，并有3\*n个数，将这3*n个数分成n组，每组三个。如何分组，能使每组中第二大的数之和最大。

<font size = 5 color = red>思路：</font>

使用**贪心**算法，对于3*n个数的分组方法，只要保证对于每一个组来说，它的第二大数是目前可选范围中最合适的数即可。

举例：现有1、2、3、4、5、6、7、8、9，这九个数字。每组3人，总共可以分3组；

对于第一组，在这九个数字中，9一定是第一个数，8为第二个数，第三个数的取值越小越好，所以第一组{9、8、？}；

对于第二组，剩下的1、2、3、4、5、6、7，这七个数字中，7为第一个数，6为第二个数，第三个数的取值越小越好，所以第二组{7、6、？}；

对于第三组，剩下的1、2、3、4、5，这五个数字中，5为第一个数，4为第二个数，第三个数的取值越小越好，所以第三组{5、4、？}；

剩下的1、2、3，随机填到这三个组中，对最终结果没有影响。

最终的结果为18.

**对贪心算法的理解：**

每次拿数据时，都“自私地”选择所有数据中最满足条件的一个，而不关心之后的组的选择。其实，如果每一组达到最优，那对于整个结果来说，也是最优的。

也就是所有的数里，最小的n个数作为每组中的

**编程思路：**

1. 将3*n个数从小到大排序（从大到小也可以）；

2. 从第n个数开始，求每隔两个数之和，直到倒数第二个数。

代码：

~~~C
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main(){
	int n;
	while (cin >> n){	//如果没有输入，则不进行以下操作
		long long sum = 0;
		vector<int> a(3 * n);
		for (int i = 0; i < (3 * n); i++){
			cin >> a[i];
		}
		sort(a.begin(), a.end());	//使用库里的函数对vector进行排序，注意包含头文件
		for (int i = n; i <= 3 * n - 2; i += 2){
			sum += a[i];
		}
		cout << sum << endl;
	}
}
~~~

*之前错误的思路：*

​	在得到正确题解之前，我之前的代码只能通过10%的测试用例，也对比出来自己思路不正确的地方。

​	我的想法是：在1、2、3、4、5、6、7、8、9这九个数中：将7、8、9分别分配给这三个组的第一大的数，再将中间的4、5、6作为每组第二大的数求和，为15。

​	这种思路将比较大的数值，浪费在第一大数的名额上，而忽略了我们本来的要求是将尽量大的数值贡献给每组的第二大数。



