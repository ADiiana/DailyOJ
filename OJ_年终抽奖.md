# OJ_年会抽奖

[年会抽奖 牛客网](https://www.nowcoder.com/questionTerminal/610e6c0387a0401fb96675f58cda8559)

**题目描述：**

>今年公司年会的奖品特别给力，但获奖的规矩却很奇葩：
>
>1. 首先，所有人员都将一张写有自己名字的字条放入抽奖箱中；
>
>2. 待所有字条加入完毕，每人从箱中取一个字条；
>
>3. 如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
>
>   现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？
>
>##### **输入描述:**
>
>```C
>输入包含多组数据，每组数据包含一个正整数n（2≤n≤20）。
>```
>
>##### **输出描述:**
>
>```C
>对应每一组数据，以“xx.xx%”的格式输出发生无人获奖的概率。
>```
>
>**示例**
>
>```C
>输入：
>2
>输出：
>50.00%
>```

<font color = red size = 5>解题思路：</font>

这是一个著名的错排问题（装信封问题，问助手有多少种装错的可能）：

瑞士著名数学家按一般情况给出一个递推公式：
$$
D(n) = (n-1)[D(n-2) + D(n-1)]\\
D(1)=0,D(2)=1
$$
不放回小球，总的抽法是$n!$

概率 = 排错问题 / n的阶乘

**题解：**

题解中很值得学习的一点是用数组取代了递归，巧用数组初始化。

注意两位小数的输出格式。

~~~C
#include <iostream>
#include <cstdio>

int main() {
	long long d[22] = { 0, 0, 1 }; // 错排数量
	long long f[22] = { 0, 1, 2 }; // 阶乘
	for (int i = 3; i < 22; i++) {
		d[i] = (i - 1) * (d[i - 1] + d[i - 2]);
		f[i] = i * f[i - 1];
	}
	int n;
	while (std::cin >> n) {
		printf("%.2f%%\n", 100.0 * d[n] / f[n]);
	}
}
~~~









