# OJ_删除链表的结点

链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/

### 题目描述

>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

```
    4 -> 5 -> 1 -> 9
```

**示例 1:**

```
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**示例 2:**

```
输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

**说明:**

- 链表至少包含两个节点。
- 链表中所有节点的值都是唯一的。
- 给定的节点为非末尾节点并且一定是链表中的一个有效节点。
- 不要从你的函数中返回任何结果。

<font color = red size = 5>思路:</font>

​	一般常规思路是，用两个一前一后的指针遍历一遍链表，后边的指针寻找要删除的结点，找到之后，将前一个指针指向要删除结点的下一个结点。

​	但是，<font color = blue>这道题并没有给出这条链表的头结点，所以不能采用遍历的方法</font>

​	<font color = brown size = 4>另一种思路：将要删除的结点变成当前结点的下一个结点。</font>

*将当前要删除结点的下一个结点的值，赋值当前结点，再删除当前节点的下一个结点即可*

**举例：**

>输入：4 ->5 ->1 -> 9      要删除的结点：5
>
>先将原链表变成：4 ->1 ->1 ->9
>
>再删除第二个1
>
>变成：4 ->1 ->9

**代码如下**

~~~c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
void deleteNode(struct ListNode* node) {
    
    struct ListNode* next = node->next;
     
    node->val = next->val;
    node->next = next->next;

}
~~~



